library(roxygen2)
library(roxygen2)
library(rmarkdown)
install.packages("mvtsplot")
library(devtools)
use_data("accident_2013.csv.bz2")
use_data("accident_2013.csv.bz2")
use_data("accident_2013.csv.bz2", internal = T)
setwd("C:/Users/rubis/Desktop/GitHubR/ProjectRGGit")
use_data("accident_2013.csv.bz2")
use_data("accident_2014.csv.bz2")
use_data_raw("accident_2014.csv.bz2")
use_data_raw("accident_2013.csv.bz2")
use_data_raw("accident_2015.csv.bz2")
#' @title fars_read
#' @description The function \code{fars_read} read a csv file if it exists and forwards the argument a data frame.
#' @param filename to enter a database with format csv.
#' @return if file exists, this function read the file and return a database as a data frame. If the extension
#' is diferent to csv, it can not read the file.
#' @details you need install packages like dplyr and readr before this or it may result in an error
#' @importFrom readr read_csv
#' @importFrom dplyr tbl_df
#' @example fars_read(filename = x)
#' @export
fars_read <- function(filename) {
if(!file.exists(filename))
stop("file '", filename, "' does not exist")
data <- suppressMessages({
readr::read_csv(filename, progress = FALSE)
})
dplyr::tbl_df(data)
}
fars_read("accident_2013.csv.bz2")
RG <- fars_read("accident_2013.csv.bz2")
colnames(RG)
head(RG)
unique(RG$STATE)
unique(RG$ST_CASE)
unique(RG$VE_TOTAL)
unique(RG$VE_FORMS)
unique(RG$PVH_INVL)
unique(RG$PEDS)
unique(RG$PERNOTMVIT)
unique(RG$PERMVIT)
order(unique(RG$PERMVIT))
RG$PERMVIT[order(unique(RG$PERMVIT))]
RG$PERMVIT[order(unique(RG$PERMVIT), decreasing = F)]
RG$PERMVIT[order((RG$PERMVIT), decreasing = F)]
unique(RG$PERMVIT[order((RG$PERMVIT), decreasing = F)])
unique(RG$PERMVIT[order((RG$PERSONS), decreasing = F)])
unique(RG$PERMVIT[order((RG$COUNTY), decreasing = F)])
unique(RG$PERMVIT[order((RG$COUNTY), decreasing = T)])
unique(RG$COUNTY[order((RG$COUNTY), decreasing = T)])
unique(RG$COUNTY[order((RG$COUNTY), decreasing = F)])
unique(RG$CITY[order((RG$CITY), decreasing = F)])
unique(RG$CITY[order((RG$CITY), decreasing = F)])[2100]
unique(RG$CITY[order((RG$CITY), decreasing = F)])[2090]
unique(RG$CITY[order((RG$CITY), decreasing = F)])[2095]
unique(RG$CITY[order((RG$CITY), decreasing = F)])[2093]
unique(RG$CITY[order((RG$CITY), decreasing = F)])[2092]
unique(RG$CITY[order((RG$CITY), decreasing = F)])[2091]
unique(RG$DAY[order((RG$DAY), decreasing = F)])[2091]
unique(RG$DAY[order((RG$DAY), decreasing = F)])
unique(RG$MONTH[order((RG$MONTH), decreasing = F)])
unique(RG$YEAR[order((RG$YEAR), decreasing = F)])
unique(RG$DAY_WEEK[order((RG$DAY_WEEK), decreasing = F)])
unique(RG$HOUR[order((RG$HOUR), decreasing = F)])
unique(RG$MINUTE[order((RG$MINUTE), decreasing = F)])
unique(RG$NHS[order((RG$NHS), decreasing = F)])
unique(RG$NHS[order((RG$ROAD_FNC), decreasing = F)])
unique(RG$ROAD_FNC[order((RG$ROAD_FNC), decreasing = F)])
unique(RG$ROUTE[order((RG$ROUTE), decreasing = F)])
unique(RG$TWAY_ID[order((RG$TWAY_ID), decreasing = F)])
unique(RG$TWAY_ID2[order((RG$TWAY_ID2), decreasing = F)])
unique(RG$MILEPT[order((RG$MILEPT), decreasing = F)])
unique(RG$MILEPT[order((RG$MILEPT), decreasing = F)])[2200]
unique(RG$MILEPT[order((RG$MILEPT), decreasing = F)])[2100]
unique(RG$MILEPT[order((RG$MILEPT), decreasing = F)])[2150]
unique(RG$MILEPT[order((RG$MILEPT), decreasing = F)])[2180]
unique(RG$MILEPT[order((RG$MILEPT), decreasing = F)])[2190]
unique(RG$MILEPT[order((RG$MILEPT), decreasing = F)])[2195]
unique(RG$MILEPT[order((RG$MILEPT), decreasing = F)])[2199]
unique(RG$LATITUDE[order((RG$LATITUDE), decreasing = F)])[2199]
unique(RG$LONGITUD[order((RG$LONGITUD), decreasing = F)])[2199]
unique(RG$SP_JUR[order((RG$LONGITUD), decreasing = F)])[2199]
unique(RG$SP_JUR[order((RG$SP_JUR), decreasing = F)])[2199]
unique(RG$SP_JUR[order((RG$SP_JUR), decreasing = F)])
unique(RG$LONGITUD[order((RG$LONGITUD), decreasing = F)])
unique(RG$SP_JUR[order((RG$SP_JUR), decreasing = F)])
unique(RG$HARM_EV[order((RG$HARM_EV), decreasing = F)])
unique(RG$MAN_COLL[order((RG$MAN_COLL), decreasing = F)])
unique(RG$RELJCT1[order((RG$RELJCT1), decreasing = F)])
unique(RG$TYP_INT[order((RG$TYP_INT), decreasing = F)])
unique(RG$WRK_ZONE[order((RG$WRK_ZONE), decreasing = F)])
unique(RG$REL_ROAD[order((RG$REL_ROAD), decreasing = F)])
unique(RG$LGT_COND[order((RG$LGT_COND), decreasing = F)])
unique(RG$WEATHER1[order((RG$WEATHER1), decreasing = F)])
unique(RG$WEATHER2[order((RG$WEATHER2), decreasing = F)])
unique(RG$WEATHER[order((RG$WEATHER), decreasing = F)])
unique(RG$SCH_BUS((RG$SCH_BUS), decreasing = F)])
unique(RG$SCH_BUS((RG$SCH_BUS))])
unique(RG$SCH_BUS)
unique(RG$RAIL)
unique(RG$NOT_HOUR)
unique(RG$NOT_MIN)
unique(RG$ARR_HOUR)
unique(RG$ARR_MIN)
unique(RG$HOSP_HR)
order(unique(RG$HOSP_HR))
RG$HOSP_HR[order(unique(RG$HOSP_HR))]
unique(RG$HOSP_HR[order(unique(RG$HOSP_HR))])
unique(RG$HOSP_MN[order(unique(RG$HOSP_MN))])
unique(RG$CF1[order(unique(RG$CF1))])
unique(RG$CF2[order(unique(RG$CF2))])
unique(RG$CF3[order(unique(RG$CF3))])
unique(RG$FATALS[order(unique(RG$FATALS])
RG$FATALS
unique(RG$FATALS)
unique(RG$DRUNK_DR
)
Documentation how to create a map R
ProjectRGGit
read a csv file when it exists and forwards the argument as a data frame.
load_all()
document()
rm(list = c("fars_read"))
document()
#' There functions used a database to create maps according a specific location.
#'
#' @title fars_read
#' @description The function \code{fars_read} read a csv file if it exists and forwards the argument a data frame.
#' @param filename to enter a database with format csv.
#' @return if file exists, this function read the file and return a database as a data frame. If the extension
#' is diferent to csv, it can not read the file.
#' @details you need install packages like dplyr and readr before this or it may result in an error
#' @importFrom readr read_csv
#' @importFrom dplyr tbl_df
#' @example fars_read(filename = x)
#' @export
fars_read <- function(filename) {
if(!file.exists(filename))
stop("file '", filename, "' does not exist")
data <- suppressMessages({
readr::read_csv(filename, progress = FALSE)
})
dplyr::tbl_df(data)
}
#' @title make_filename
#' @description The function \code{make_file} transform a variable as a integer and print a character vector
#' containing a formatted combination of text and variable value.
#' @param year as a variable to tranform it in an integer value.
#' @return a character vector containing a formatted combination of text and variable value.
#' @details you need enter a number or it return a NA.
#' @importFrom base as.integer sprintf
#' @examples make_filename(2014)
#' @export
make_filename <- function(year) {
year <- as.integer(year)
sprintf("accident_%d.csv.bz2", year)
}
#' @title fars_read_years
#' @description The function \code{fars_read_years} save the name of a specific data base according to a year,
#' read the ddatabase and transmute it drops existing variables as year.
#' @param years as a variable to tranform it in an integer value accross \code{make_filename}. It will be used
#' when it generate the name of a file with the function \code{fars_read}.
#' @return if the year is in the set: 2013, 2014 or 2015, it will transmute a database in a new data frame depending
#' on a specific month. Otherwise it will print a warning.
#' @details you need enter a number as a year contained in the set: 2013, 2014 or 2015 or it will return a warning
#' as a message.
#' @importFrom dplyr mutate select
#' @examples fars_read_years(2014)
#' @export
fars_read_years <- function(years) {
lapply(years, function(year) {
file <- make_filename(year)
tryCatch({
dat <- fars_read(file)
dplyr::mutate(dat, year = year) %>%
dplyr::select(MONTH, year)
}, error = function(e) {
warning("invalid year: ", year)
return(NULL)
})
})
}
#' @title fars_summarize_years
#' @description The function \code{fars_summarize_years} transmute the data frame by group, summarize and
#' spread a key-value pair across the variables year and n.
#' @param years as a variable to read the other functions and transmute the data frame.
#' @return a data frame by group of year and month, and summarize by count. It will print the head of the database.
#' @details you need install the library tidyr and conserve the format of the variables.
#' @importFrom dplyr bind_rows group_by summarize
#' @importFrom tidyr spread
#' @examples fars_summarize_years(2014)
#' @export
fars_summarize_years <- function(years) {
dat_list <- fars_read_years(years)
dplyr::bind_rows(dat_list) %>%
dplyr::group_by(year, MONTH) %>%
dplyr::summarize(n = n()) %>%
tidyr::spread(year, n)
}
#' @title fars_map_state
#' @description The function \code{fars_map_state} transform the principal database and add
#' conditionals for some variables. Plot a map with a specific lat and long.
#' @param state.num as a variable that represent a state.
#' @param year as a variable to tranform it in an integer value.
#' @return if number of a state is unique and it is contained in the variable STATE of the data
#' it will make a data frame with this filter, with conditionals to transform NAs in the
#' variables LONGITUD AND LATITUDE and print a map with this location. Otherwise print a
#' message "no accidents to plot" and return an invisible object.
#' @details you need to install the package "map" and specify a number of a state.
#' @importFrom dplyr filter
#' @importFrom base message invisible
#' @importFrom maps map
#' @importFrom graphics points
#' @examples fars_map_state(19, 2014)
#' @export
fars_map_state <- function(state.num, year) {
filename <- make_filename(year)
data <- fars_read(filename)
state.num <- as.integer(state.num)
if(!(state.num %in% unique(data$STATE)))
stop("invalid STATE number: ", state.num)
data.sub <- dplyr::filter(data, STATE == state.num)
if(nrow(data.sub) == 0L) {
message("no accidents to plot")
return(invisible(NULL))
}
is.na(data.sub$LONGITUD) <- data.sub$LONGITUD > 900
is.na(data.sub$LATITUDE) <- data.sub$LATITUDE > 90
with(data.sub, {
maps::map("state", ylim = range(LATITUDE, na.rm = TRUE),
xlim = range(LONGITUD, na.rm = TRUE))
graphics::points(LONGITUD, LATITUDE, pch = 46)
})
}
x <- make_filename(2013)
x
y <- fars_read(x)
z <- fars_read_years(2013)
fars_map_state(19,2013)
y
use_data("accident_2013.csv.bz2")
use_data("accident_2013.csv.bz2", internal = T)
use_data()
use_data("accident_2013.csv.bz2")
use_data("accident_2013.csv")
use_data("accident_2013.csv")
data1 <- fars_read("accident_2013.csv.bz2")
data2 <- fars_read("accident_2014.csv.bz2")
data3 <- fars_read("accident_2015.csv.bz2")
use_data(data1)
use_data(data2)
use_data(data3)
accident_2013.csv.bz2 <- fars_read("accident_2013.csv.bz2")
use_data(accident_2013.csv.bz2)
use_testthat()
use_testthat("example1")
use_test
use_test()
use_test("fars_functions.R")
fars_read <- function(filename) {
if(!file.exists(filename))
stop("file '", filename, "' does not exist")
data <- suppressMessages({
readr::read_csv(filename, progress = FALSE)
})
dplyr::tbl_df(data)
}
fars_read(accident_2013.csv.bz2)
fars_read("accident_2013.csv.bz2")
load_all()
rm(list = c("fars_map_state", "fars_read", "fars_read_years", "fars_summarize_years", "make_filename"))
load_all()
document()
document()
use_readme_rmd("README.Rmd")
use_readme_rmd(README.Rmd)
use_readme_rmd()
library(devtools)
use_travis()
document()
load("C:/Users/rubis/Desktop/GitHubR/ProjectRGGit/data/data1.rda")
load("C:/Users/rubis/Desktop/GitHubR/ProjectRGGit/data/data1.rda")
load("C:/Users/rubis/Desktop/GitHubR/ProjectRGGit/data/accident_2013-csv-bz2.rda")
load_all()
document()
load_all()
load_all()
document()
load_all()
document()
data1
use_data(data1)
use_data(data1, overwrite = T)
accaccident_2013.csv.bz2 <- data1
accident_2013.csv.bz2 <- data1
use_data(accident_2013.csv.bz2)
accident_2014.csv.bz2 <- data2
accident_2015.csv.bz2 <- data3
use_data(accident_2014.csv.bz2)
use_data(accident_2015.csv.bz2)
load_all()
document()
load_all()
document()
load_all()
document()
load_all()
document()
document()
document()
load_all()
document()
load_all()
document()
load_all()
document()
load_all()
document()
load_all()
devtools::load_all(".")
use_travis()
env.profile()
environment()
load_all()
document()
load_all()
document()
detach("stats")
detach("package:stats", unload = T)
library(ProjectRGGit)
context("Test output")
load_all()
document()
library(dplyr)
conflicts(detail = T)
getAnywhere(filter)
[]
getAnywhere(filter)[1]
getAnywhere(filter)[2]
getAnywhere(filter)[3]
getAnywhere("lag")
getAnywhere("filter")
getAnywhere(filter())[1]
vignette('programming')
library(dplyr)
getAnywhere(filter())[2]
lifecycle::last_warnings()
library(devtools)
load_all()
document()
